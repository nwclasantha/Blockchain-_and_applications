Interactive HTML and Python-based Blockchain Simulators for Networks and Security Research
Abstract
Blockchain systems have become a critical focus in computer networks and cybersecurity research, motivating the development of specialized simulators for education and experimentation. This article presents a comprehensive overview of a suite of HTML-based and Python-based blockchain simulators derived from academic lecture materials. We detail the design principles, features, and use-cases of these simulators, which span fundamental concepts (basic blockchains and cryptography), consensus algorithms, cryptocurrency operations, smart contract behaviors, security attacks, and domain-specific applications. We discuss how the simulators model blockchain architecture and workflows, highlighting interactive web-based tools alongside script-driven Python models. Key insights from simulation results are analyzed – demonstrating consensus dynamics, cryptographic verification processes, attack scenarios, and performance trade-offs – to illustrate their relevance for research in distributed networks and security. The article also compares the capabilities of HTML vs. Python simulators and situates them in context with related academic tools. The outcome is a detailed guide to using and extending these simulators for academic research, with emphasis on their educational value and potential to accelerate development and evaluation of new blockchain network and security mechanisms.
Keywords
Blockchain Simulation; Consensus Algorithms; Computer Networks; Cybersecurity; Smart Contracts; Distributed Ledger Technology (DLT)
Introduction
Blockchain technology is a distributed ledger system where nodes achieve agreement (consensus) on transaction history despite faults or adversaries. Given blockchains’ distributed nature and security-critical design, simulation tools have emerged as valuable assets for researchers to test new ideas and analyze system behavior under various scenarios
dpss.inesc-id.pt
. Simulation allows controlled experimentation on network protocols, consensus algorithms, and attack strategies without the cost or risk of deploying on real networks
phys.org
phys.org
. In both the computer networks and cybersecurity domains, researchers have leveraged simulators to study performance bottlenecks, security vulnerabilities, and potential improvements in blockchain systems. This article provides a comprehensive review of a collection of interactive blockchain simulators developed in two formats – web-based HTML/JavaScript and console-based Python – covering a wide range of topics from fundamental blockchain concepts to advanced security scenarios. These simulators were originally created as educational tools in academic lectures, but they also serve as research testbeds for exploring new blockchain mechanisms. We aim to document their functionalities, design, and application scenarios in an IEEE-style format suitable for academic audiences. We organize the simulators by thematic categories (e.g., cryptographic primitives, consensus mechanisms, etc.) and examine how each category’s tools are implemented and what insights they provide. The contributions of this work are as follows: (1) We systematically describe the architecture and workflow of each simulator (both HTML and Python versions), highlighting design principles like modularity (e.g., classes for blocks, transactions, nodes) and interactivity. (2) We illustrate how these simulators can be used to demonstrate key concepts in blockchain networks and security – for example, how proof-of-work mining is modeled or how smart contract vulnerabilities can be explored. (3) We present sample results and analyses from using the simulators, showcasing their ability to reproduce known behaviors (such as consensus thresholds or attack success conditions) and inform research questions. (4) We compare the simulators’ capabilities, noting the differences between the visually rich HTML tools and the flexible Python scripts, and we discuss their place relative to other academic simulation frameworks. The remainder of the paper is structured as follows. Section II (Related Work) briefly surveys other blockchain simulators and positions our presented tools in context. Section III (Methodology) outlines the design methodology and software architecture underlying the simulators. Section IV (Simulator Descriptions) provides in-depth descriptions of each category of simulator (cryptography, consensus, transactions, smart contracts, security attacks, and applications), including their functionality and example usage. Section V (Results and Analysis) discusses the outcomes observed from running these simulators and the lessons for network and security research – including performance considerations and security implications. Section VI (Discussion) addresses the significance, limitations, and potential extensions of the simulators. Finally, Section VII (Conclusion) summarizes the findings and emphasizes the value of interactive simulation tools for advancing blockchain research in networks and cybersecurity.
Related Work
Blockchain simulation has garnered attention in both industry and academia as a means to evaluate new protocols and configurations without risking live networks. Prior research has produced general-purpose blockchain simulators that complement the educational tools described in this paper. For instance, BlockSim
dpss.inesc-id.pt
dpss.inesc-id.pt
 is a discrete-event simulation framework that models blockchain components (transactions, blocks, network channels) and allows performance evaluation of different designs. BlockSim’s authors highlight the need for flexible simulators to rapidly prototype and assess modifications to blockchain systems, noting that lack of evaluation tools can impede progress in the field
dpss.inesc-id.pt
. Another notable example is SimBlock, a Java-based simulator capable of modeling large-scale public blockchain networks (up to thousands of nodes) on a single machine
phys.org
. SimBlock provides a visualizer for block propagation and has been used to test the impact of network topology and node behavior changes on both performance and security
phys.org
phys.org
. Such frameworks enable researchers to simulate malicious nodes, measure attack success rates, and evaluate countermeasures in a reproducible environment
phys.org
. Beyond these, various specialized simulators exist. Shadow-Bitcoin and Shadow-Ethereum integrate blockchain logic into the Shadow network simulator to study malware and privacy in realistic network conditions
dpss.inesc-id.pt
. NS-3 has been extended with blockchain modules to analyze network-layer performance of protocols like Bitcoin. Other academic tools like BlockBench focus on benchmarking private (permissioned) blockchains, while projects such as Ethereum Visual Studio and others provide sandbox environments for smart contracts. Each of these tools addresses specific research needs – e.g., scaling performance, analyzing consensus under different assumptions, or testing smart contract execution. Comparatively, the simulators we discuss in this article were originally developed for pedagogical purposes, closely mirroring core blockchain concepts and algorithms. They differ from heavy discrete-event simulators in that they often prioritize clarity and accessibility (sometimes with interactive GUIs or straightforward scripts) over complex network realism. Nonetheless, they fill an important niche. Tools like the ones presented can be seen as concept simulators – they model the logical behavior of blockchain processes (mining, transaction verification, consensus voting, etc.) in a simplified form, which is extremely useful for both teaching and rapid prototyping of new ideas. In the following sections, we detail these simulators and show how they remain relevant to research by allowing fine-grained exploration of algorithmic behavior and security mechanisms.
Methodology
Design Approach: The simulators are built on an object-oriented and modular design that mirrors the real-world structure of blockchain systems. In the Python-based simulators, core entities such as Block, Blockchain (ledger), Transaction, Node, Miner, and SmartContract are implemented as classes, encapsulating the data and behaviors of those components. This enables simulations to be constructed by instantiating objects and invoking methods that simulate real operations (e.g., mining a block, signing a transaction, verifying a signature). For example, an educational blockchain simulator in Python defines classes for Transaction, SmartContract, Block, User, and Blockchain to model on-chain operations and state changes in a self-contained way. This mirrors the layered architecture of actual blockchain software, separating concerns of data (transactions/blocks) from consensus logic and network interaction. In the HTML/JavaScript-based simulators, the design is event-driven and user-interactive. These simulators run in a web browser, using client-side scripts (JavaScript/TypeScript) to update the simulation state and visualization in response to user inputs (button clicks, form entries) or timed events. The HTML simulators typically provide a graphical interface – for instance, a web page might display a “Blockchain” tab showing blocks being added, a “Network” view animating messages between nodes, or a “Results” panel summarizing outputs. Under the hood, the logic might utilize frameworks like D3.js or custom drawing routines on HTML5 <canvas> elements to visualize processes like cryptographic hashing or block propagation. The separation of concerns is similar: simulation logic is implemented in script functions, while the HTML/CSS handles layout and user interface elements. This allows researchers or students to intuitively manipulate parameters (like consensus algorithm selection or number of malicious nodes) via the UI and immediately observe effects on the simulated blockchain’s behavior. Simulation Workflow: Each simulator, regardless of implementation, follows a discrete sequence of steps representing the target process. For instance, a blockchain mining simulator will iterate through the lifecycle of adding a new block: gather transactions, compute a hash with a proof-of-work loop, validate the solution, and finally append the block to the chain. In Python, this might be done with loops and conditional logic, printing each step to the console. In an HTML simulator, the same sequence would be represented with animations or step-by-step updates on the webpage (often with a “Start” or “Next Step” button to progress). Many simulators incorporate randomized elements to mimic nondeterministic aspects of real networks. For example, consensus simulators often randomize which miner finds a proof-of-work solution first, or which validator is chosen in proof-of-stake, to demonstrate how probability influences leadership selection. This is usually done with Python’s random module or JavaScript’s random functions. Time delays can also be simulated (e.g., using time.sleep() in Python or timed callbacks in JavaScript) to illustrate message latency or processing time, though in most educational cases the emphasis is on logical outcome rather than real-time duration. Architecture and Extensibility: A key design principle across these simulators is extensibility. By structuring the code into distinct modules and classes, one can easily modify or replace components to explore hypothetical scenarios. For example, the consensus simulation framework includes an enumeration of consensus types (PROOF_OF_WORK, PROOF_OF_STAKE, PBFT, etc.) and could allow plugging in a new consensus algorithm by adding a class or branching logic for that algorithm. Similarly, network topology effects are abstracted (e.g., an advanced simulator defines NetworkTopology as an enum with values like MESH, STAR, RING), enabling studies of how node connectivity impacts performance and security. On the web-based side, simulators often separate the visual layer from the simulation logic. This means a researcher could take the underlying JavaScript that implements, say, the consensus decision logic or the block construction, and adapt it to different visualization frontends or integrate it into other tools. The HTML simulators typically use clear sectioned code (with comments) for each major function (e.g., a mineBlock() function, a verifySignature() function, etc.), making it straightforward to identify where one might tweak the difficulty parameter or the cryptographic algorithm for experimentation. Validation: While these simulators are not full-scale network emulators, their logic is validated against known blockchain behavior and theoretical expectations. For example, the proof-of-work mining simulation ensures that the hash computed starts with the requisite number of leading zeros to be considered a valid block (imitating Bitcoin’s difficulty criterion). The proof-of-stake simulation uses a weighted random selection proportional to stakeholders’ amounts, reflecting the fundamental idea behind PoS consensus. Many simulators include checks and print statements for critical conditions (e.g., in a PBFT simulation, whether consensus was achieved or failed given a number of malicious nodes) to confirm that the outcomes align with Byzantine Fault Tolerance thresholds. By structuring the simulators in this methodical way – object-oriented design, event-driven interactivity, and alignment with theoretical models – the authors of the lecture materials created tools that not only educate but also can be trusted (to a reasonable extent) to simulate “what if” scenarios in blockchain networks. In the next section, we delve into the specific simulators and their functionalities, following the methodological principles described here.
Simulator Descriptions
In this section, we categorize and describe the simulators, dividing them into thematic groups. Each subsection outlines both Python-based and HTML-based simulators (if available) for that category, explaining their features, workflows, and example application scenarios. Figures are provided to illustrate key workflows for select simulators.
A. Blockchain Basics and Architecture Simulators
The first set of simulators introduces fundamental blockchain data structures and operations. A basic blockchain simulator (provided in both Python and HTML form) demonstrates how a chain of blocks is constructed, how each block links via hashes, and how new transactions are added.
Python “Blockchain” Simulator: In the Python lecture code, a simple blockchain is represented by classes like Block and Blockchain. Blocks contain fields such as index, timestamp, list of transactions, previous hash, and their own hash computed via SHA-256. The simulator lets users create a new block by providing dummy transaction data; the block’s hash is computed by hashing together the block’s contents (simulating a Merkel root or concatenation of transactions and previous hash). The blockchain is essentially a list of Block objects. The code ensures that when a new block is appended, its prev_hash matches the hash of the last block in the chain, thereby maintaining continuity (and if a mismatch is forced, it can flag an integrity error). This helps researchers understand the immutability and linking property of blockchains. Some Python scripts also illustrate the block lifecycle – from creation to validation. For instance, they use a function lifecycle.py (in the lecture materials) to simulate the steps a block goes through: created, broadcast, validated by miners, and finally added to the main chain. The output logs each step so the user can follow the workflow.
HTML Blockchain Simulator: An HTML-based simulator (often labeled "Blockchain Simulator v2" or similar) provides a visual animation of blocks being added to a chain. The webpage typically shows a block diagram that gets extended with each new block. Users can input a block’s transactions or click “Add Block,” upon which the simulator will simulate computing a hash and then attach a new block graphic to the chain display. Some implementations also highlight the nonce finding process even for a simple chain (not full proof-of-work difficulty, but demonstrating the notion of a nonce to achieve a hash condition). This interactive tool is useful in classrooms – students can see a block’s content (e.g., a list of transactions) and how altering it changes the hash, reinforcing the concept of tamper-evidence in blockchains.
Advanced Architecture Simulator: In the Python collection, there is also an Advanced Blockchain Network Simulator (nicknamed ChainEdgeStudio in the files) described as an “enterprise-grade blockchain simulation with multiple consensus algorithms, network topology, DeFi protocols, cross-chain bridges, and real-time...” in the code documentation. This hints at a comprehensive simulation environment wherein not only the block and chain structure is modeled, but also various network topologies (mesh, star, ring) and advanced features like cross-chain interaction and decentralized finance (DeFi) modules. Such a simulator is architecturally more complex: it likely contains modules for a peer-to-peer network overlay, consensus mechanism plugins, and perhaps a rudimentary economic model (for DeFi). While this goes beyond basics, mentioning it here underscores that the architecture of simpler simulators can scale up – the design of separate components (Block, Node, Network, Consensus, TransactionType, etc.) enables building a more integrated network simulation that encompasses entire blockchain ecosystems.
Workflow Example – Block Addition: A representative workflow from this category is the block mining/creation flowchart. Figure 1 illustrates the process that a basic blockchain mining simulator might follow, in a flow-diagram form, from receiving new transaction data to successfully mining and adding a block. The process starts with an initial state and goes through steps like timestamping the block, computing a Merkle root of transactions, initializing a nonce, hashing the block data, and checking if the hash meets a required condition (e.g., starts with N zeros for difficulty). If not, the nonce is incremented and hashing retried, until a valid hash is found (“Block Successfully Mined”), at which point the block is finalized and linked to the chain (end state). Figure 1 is based on the lecture’s block mining process diagram and corresponds to the logic implemented in the Python proof-of-work simulator (described in the next subsection on consensus). It exemplifies the sequence of operations and decision points: 

Figure 1: Workflow of block creation and proof-of-work mining in the blockchain simulator. The flow starts with a new block input and iteratively finds a nonce that produces a hash with the required difficulty, resulting in a mined block being added to the chain.
B. Cryptography and Security Primitives Simulators
Cryptographic primitives underlie blockchain security; accordingly, the lecture materials include simulators to demonstrate hashing, key generation, digital signatures, and Merkle trees. These are essential for researchers to grasp how low-level cryptographic functions ensure integrity and authenticity in a blockchain network.
Hash Function Demo (Python): A Python script hash_function_demo.py showcases the properties of a cryptographic hash (SHA-256). It takes an input (e.g., the string "hello blockchain" in the code) and computes its SHA-256 hash. The simulator prints the original data and the resulting hash, then performs experiments such as hashing the same input again (to confirm deterministic consistency) and hashing a slightly different input (to illustrate the avalanche effect, wherein a small change in input drastically changes the output). For example, it will output that the hash of "hello blockchain" is (say) 3a3...f0 and that hashing the same input again yields the same hash【48†】, whereas adding an exclamation mark to the input produces a completely different hash (demonstrating one-way and collision-resistant properties). This simple simulator helps researchers confirm the reliability of hash functions in ensuring data integrity. It can be extended to test other hash algorithms or even to measure performance (time to hash large inputs) if needed.
Public/Private Key Generation Demo (Python): In key_generation_demo.py, the process of generating an RSA key pair is simulated. Using a cryptography library, the script creates a private key and derives the corresponding public key, then prints them in PEM format【52†】. This shows what real cryptographic keys look like and emphasizes the concept of public-key cryptography which is fundamental for blockchain addresses and signatures. Researchers interested in security can use this to understand key size, format, or to plug in different key types (RSA vs ECC) for comparison.
Digital Signature Simulator (Python): The script digital_signature_demo.py ties hashing and key generation together to demonstrate digital signatures. It generates a key pair (or uses a preset one), hashes a sample message, signs the hash with the private key, and then attempts to verify it with the public key. The outcome is printed as a success or failure. For instance, if the message is "Transfer 5 BTC from Alice to Bob" the simulator will output the signature (often as a long hexadecimal string) and then print a message like “✅ Signature is valid!” if verification passes【50†】. If the message had been tampered or the wrong public key used, it would print “❌ Signature invalid.” This directly mirrors how Bitcoin transactions are signed by owners and verified by nodes. Researchers can modify this simulator to experiment with signature schemes or to see how signature size or verification time scales with key sizes.
Merkle Tree Simulator (Python): Blockchain scalability and integrity often rely on Merkle trees. The merkle_tree_demo.py script allows input of a list of transaction hashes and then builds a Merkle tree, computing the Merkle Root【53†】. It typically prints the final root hash. In more interactive versions, it could also print intermediate pair hashes or even visualize the tree structure. By using this simulator, one can understand how transactions are paired and hashed repeatedly to produce a single root, and how any change in any transaction propagates up to change the root (ensuring tamper detection at scale). This is especially relevant in light clients and SPV (Simplified Payment Verification) in cryptocurrencies.
Combined Cryptographic Blockchain Security Demo: An HTML simulator (and a corresponding Python script cryptographic_blockchain_security_demo.py) integrates the above primitives to show a full flow of securing a transaction. The flowchart in Figure 2 illustrates this integrated process: a transaction “Alice pays Bob 5 BTC” is taken as input, then hashed with SHA-256, then signed with a newly generated RSA private key, and finally the signature is verified with the corresponding public key. The simulator will output whether the verification was successful. This end-to-end demonstration encapsulates how a blockchain ensures a transaction is authentic (owner signed it) and intact (hash links to what was signed).


Figure 2: Cryptographic security workflow in the blockchain context. The simulator takes transaction data, hashes it (SHA-256), generates a key pair, signs the hash, and verifies the signature. If the signature matches (Yes branch), the transaction is deemed valid; otherwise (No branch) it is rejected. This illustrates the use of cryptographic hashes and digital signatures to secure blockchain transactions. In the HTML version of this simulator, the web interface might allow the user to input a custom transaction string and then click “Sign” or “Verify” to see the process outcome. The interface could show the hash computed and a (truncated) signature, emulating what happens in a cryptocurrency wallet when you sign a transaction. This is highly relevant for cybersecurity research as it visually demonstrates the integrity protection mechanism – an attacker altering the transaction would produce a different hash and the original signature would fail verification, hence the blockchain nodes would reject it.
C. Consensus Algorithm Simulators
Consensus algorithms are at the heart of blockchain network research. The lecture simulators include both Python and HTML tools to model popular consensus protocols: Proof of Work (PoW), Proof of Stake (PoS), Delegated PoS, Practical Byzantine Fault Tolerance (PBFT), and even conceptual demos like the Byzantine Generals Problem. These simulators are invaluable for exploring how consensus is reached (or how it can fail) under various conditions.
Proof of Work (Mining) Simulator (Python): The proof_of_work_simulation.py script creates a scenario with multiple miners racing to mine a new block. Each miner continuously hashes a block’s contents with an incrementing nonce until a hash with the required difficulty (e.g., a prefix of four “0” digits) is found. The script uses multiple Miner instances (e.g., Alice, Bob, Charlie) and effectively simulates a competition: whichever miner finds a valid nonce first “wins” and mines the block. The output log shows a “Starting mining competition...” followed by the winner and details: e.g., “🏆 Winner: Bob – Nonce: 1315 – Hash: 0000...ca7 – Time Taken: 0.23 seconds”【108†】. This simulator helps researchers understand how block frequency and mining probability relate to hash difficulty and miner hash power. By adjusting the difficulty parameter in the code, one can observe that higher difficulty drastically increases the time (or number of attempts) needed to find a valid hash, reflecting the exponential nature of PoW. It also implicitly illustrates the energy/resource aspect: a higher difficulty means more computational work on average, which is central to blockchain’s security (making attacks costly). The Python implementation measures time taken, which could be used to infer performance scaling. For example, increasing difficulty from 4 to 5 (number of leading hex zeroes) might increase average mining time from milliseconds to fractions of a second in this simulation, consistent with an expected 16× increase in work per additional zero.
Proof of Stake Simulator (Python): In proof_of_stake_simulation.py, the consensus mechanism is simulated by randomly selecting a “validator” weighted by their stake. The script defines Validator objects with names and stake values (e.g., Alice has 50 tokens, Bob 30, Charlie 20). It then creates a “weighted pool” where each validator’s name appears proportional to their stake (so Alice appears 50 times, Bob 30, etc.), and picks a random entry from this pool to decide who creates the next block【36†】. The console output prints something like “Selecting validator based on stake... 🏆 Selected Validator: Alice”【39†】. Because Alice had the largest stake, she had the highest probability and indeed might be selected most runs. This simulator conveys the principle that the more one stakes, the more often one is trusted to propose blocks, which is the basis of PoS systems. Researchers can modify the stakes to see how probabilities change, or incorporate malicious behavior (e.g., what if a malicious validator with large stake is present?). Notably, the simulator also includes a simple visualization function that could print a bar chart of stakes or similar, helping to conceptualize stake distribution.
Delegated Proof of Stake (DPoS) and Consensus Selector: Another script, delegated_pos_simulation.py, likely extends the PoS concept by introducing the notion of elected delegates or validators (as in systems like EOS or Steem). It might simulate rounds of voting or selection of a committee of validators, then choosing a block producer among them. Although details are not printed in our summary, such a simulator would help illustrate governance aspects – e.g., how stakeholders elect delegates and how those delegates rotate in producing blocks. Additionally, a consensus_selector_demo.py allows dynamic switching between consensus models. It might present a scenario and allow the user (or code) to pick which consensus to simulate (PoW vs PoS vs PBFT) and then observe outcomes. This is useful for comparing algorithms: for instance, a comparison might show that PoW eventually finds a single winner (with wasted work for others), whereas PBFT involves all nodes agreeing on one proposal, etc.
Practical Byzantine Fault Tolerance (PBFT) Simulator (Python): The pbft_simulation.py script models a small network of nodes reaching consensus through a PBFT-like protocol. PBFT normally tolerates up to f faulty nodes in a network of 3f+1 nodes. In the provided code, they instantiate, for example, 4 nodes (which corresponds to f=1 Byzantine fault tolerance). One of these is deliberately marked malicious. Each node “proposes” a block (which could be a dummy value or transaction set)【40†】, and then the simulator checks if a supermajority agreement exists on one of the proposals. The output might list each node’s proposal and then either “✅ Consensus Achieved on Good Block” or “❌ Consensus Failed”【42†】. Given 4 nodes with 1 malicious, we expect consensus can be achieved (since 3 honest nodes agree, fulfilling the required 3 out of 4). If we changed it to 2 malicious out of 4, consensus should fail (since honest nodes would be 2 which is not >2f). The simulator thereby concretely demonstrates the Byzantine Generals Problem solution threshold: consensus is only possible if faults < 1/3. This is crucial for security research, as PBFT-type algorithms are common in permissioned blockchains and understanding their fault tolerance limits is key. The simulation shows how even with one node proposing a bad block, the honest majority can still settle on the correct block.
Byzantine Generals Problem Demo (Python): While PBFT is a solution, a separate byzantine_generals_problem_demo.py explicitly demonstrates the classic problem setup. It may simulate a set of generals (nodes) each voting “Attack” or “Retreat,” with some traitors among them flipping votes or sending inconsistent messages. The simulator likely prints each general’s vote and then what the final decision is according to majority【43†】【44†】. For example, if 1 out of 3 generals is a traitor and votes differently to different parties, the decision algorithm might still conclude a majority decision (say, “Attack”) if the loyal generals’ votes align. The output “Decision: Attack” or “Decision: Retreat” confirms whether consensus was reached. If too many generals are traitors, the votes could be split and the decision fails or is arbitrary, illustrating the need for the 2/3 majority rule. This demo ties directly into the theory behind PBFT and other BFT protocols and is a didactic tool for researchers to see the mechanics of consensus failure when trust assumptions are violated.
HTML Consensus Simulator: The HTML counterpart (likely named something like blockchain_consensus_simulator.html) provides a more visual experiment with consensus. It might allow the user to toggle how many nodes are Byzantine (malicious) and then run a consensus round for an algorithm like PBFT. The interface could show nodes as icons exchanging messages (prepare, commit phases perhaps) and then highlight whether they agreed on a block or not. Another mode could illustrate PoW by having an animated “race” where miners are depicted and a progress bar or counter shows each trying hashes until one wins. Yet another tab might illustrate PoS by showing a lottery wheel or weighted random selection picking a validator. This interactive demo makes abstract concepts like “51% attack” or “2f+1 votes needed” much more tangible. For example, a user could simulate a PBFT network with 4 nodes, mark one as faulty, and visually see that the consensus outcome is still reached (perhaps with 3 green check-marks vs 1 red cross), whereas with two faults, the interface might show consensus aborted or conflicting.
Takeaway: These consensus simulators collectively allow researchers to compare consensus protocols in a qualitative way. One can see how PoW relies on probability and resource expenditure, whereas PBFT relies on voting and trust assumptions. Some Python simulations even combine scenarios: e.g., a consensus_comparison_sim.py (found under a later category) prints outcomes for a public PoW chain vs a private PBFT chain side by side【79†】. It shows, for instance, “Mining with Proof of Work... ✅ Block added after solving hash” and “Reaching consensus using PBFT... ✅ Consensus achieved” in one run, indicating both systems succeeded under their rules. It may also simulate failure cases: “❌ Consensus failed due to too many faults” for PBFT if we overload it with Byzantine nodes【79†】. This provides a direct comparison of resilience: PoW might always produce a block but at the cost of potential forks (which the simulator could illustrate as a temporarily orphaned block if two miners win near-simultaneously), while PBFT may halt if faults exceed the threshold. For an academic audience, such nuanced insights are valuable – they reinforce why one protocol might be chosen over another depending on the network context (public vs private, adversary model, etc.).
D. Cryptocurrency Transaction and Wallet Simulators (Bitcoin & Ethereum)
Moving beyond consensus, the simulators also delve into specifics of cryptocurrency operations, focusing on Bitcoin and Ethereum mechanics. These tools highlight how transactions are formed, validated, and processed, as well as features like gas fees and wallets.
Bitcoin Transaction and UTXO Simulators (Python): A set of Python scripts in Module 5 of the lecture materials target Bitcoin’s transaction model. The UTXO (Unspent Transaction Output) Model Demo (utxo_model_demo.py) creates a scenario where, for example, Alice has certain UTXOs (say 2 BTC and 1.5 BTC outputs). The simulator tries to have Alice send 1 BTC to Bob. It will print Alice’s UTXOs before and after, as well as which UTXOs were used and what remains【59†】. For instance, it might output: “Alice’s UTXOs: [2.0, 1.5]; Sending 1 BTC to Bob... Used UTXOs: [1.0]; Remaining UTXOs: [1.0, 1.5]” (if it created change output of 1.0 back to Alice). If Alice tried to send more than she has, it prints “❌ Insufficient funds”【59†】. This simulator teaches how Bitcoin transactions consume inputs and produce outputs (and how change is calculated), which is crucial for understanding double-spending and coin management in research. The Bitcoin Transaction Signature Simulator (bitcoin_transaction_simulation.py) parallels the earlier digital signature demo but in a Bitcoin context. It likely forms a fake transaction (with inputs, outputs, amounts), hashes the transaction data, and uses a private key to sign that hash. It then verifies the signature with the public key, simulating how a Bitcoin node would verify a transaction’s authenticity. The output might be: “Transaction Data: {…} Signature: <hex> ✅ Verified”【61†】. This confirms that only someone with the private key (the owner of the source address) could have produced the signature, thus the transaction is valid. It’s a direct application of public-key crypto in the cryptocurrency domain and helps researchers see how cryptographic validation prevents forgery of transactions. A Transaction Fee and Priority Simulator (transaction_fee_priority.py) addresses how miners prioritize transactions by fees. The code generates a list of transactions each with a fee value and simulates a block selection of the highest-fee transactions. The output prints the list of transactions that were included in the block in descending fee order【58†】. For example: “Transactions included in block (highest fee priority): TX5 – Fee: 0.002 BTC; TX3 – Fee: 0.0015 BTC; …”. This reflects Bitcoin’s mempool policy where higher fee/byte transactions get mined first. Researchers can use this to study incentive mechanisms or to evaluate how different fee distributions might affect confirmation times (though a simple script won’t do time modeling, it sets the stage for thinking about those issues). Additionally, a Mining Simulator (mining_simulation.py) measures the time to mine a block at a given difficulty. It essentially implements a PoW loop for a single miner and records how long it takes to find a valid nonce. The output might say “✅ Block Mined in 0.65s – Nonce: 1,052,203 – Hash: 00000abcd...”. By running this for different difficulties, one can empirically confirm the growth in required work. Such a simulator is useful for performance research – e.g., to estimate how a change in difficulty or hash algorithm efficiency would influence block times.
Wallet and Address Simulator (Python): A script wallet_and_address.py demonstrates how a Bitcoin wallet generates a new address. It likely creates a new ECDSA key pair (or uses RSA for simplicity in the demo), then derives a public address from the public key (perhaps by hashing it and adding network bytes like real Bitcoin addresses). The simulator prints out the results: “🔐 Your Bitcoin Address: 1ABC...; Private Key: <base58 or hex>”【60†】. This demystifies the process of address creation and shows the role of random key generation in wallet security. It’s a simple but powerful illustration of how identities on the blockchain are just public/private key pairs.
Ethereum Simulators (Python): In Module 6, simulators pivot to Ethereum, introducing concepts like gas, the EVM (Ethereum Virtual Machine), and smart contracts. The Bitcoin vs Ethereum Comparison (btc_vs_eth_comparison.py) prints a side-by-side comparison of key parameters for Bitcoin and Ethereum【62†】. For example, it may show a table of attributes: Consensus: Bitcoin – PoW, Ethereum – PoW/PoS (depending on version); Block Time: Bitcoin – ~10 min, Ethereum – ~15 sec; Transactions per block: etc. The output lines format suggests it iterated through a dictionary of features, outputting each feature with Bitcoin vs Ethereum values【62†】. This sets context for why Ethereum can handle more transactions or how its faster blocks affect security, etc. It’s less of a simulator and more of an informational summary, but useful to highlight differences. The Ethereum PoS (Eth2.0) Validator Simulator (eth2_pos_validator_sim.py) is analogous to the earlier PoS simulator but tailored to Ethereum 2.0’s consensus (Proof of Stake with a beacon chain and validator set). It likely picks a random validator to propose a block in a given slot. The code snippet shows validators with weights and then selects a winner “🏆 Chosen Validator (Eth2 PoS): [Name]”【64†】. The twist in Eth2 is that the probability might not be purely linear with stake (since there’s a pseudo-random shuffling and epoch concept), but this simulator simplifies it to demonstrate the idea that in each round one validator is pseudo-randomly chosen. Researchers can observe how even someone with smaller stake eventually gets a chance, reflecting decentralized participation. EVM Execution Simulator (evm_execution_simulator.py): This is a particularly interesting tool modeling how a smart contract executes on the Ethereum Virtual Machine. The simulator could define a simple contract (like a token contract with a transfer function) and then simulate calling that function with certain parameters. As seen in the code, it prints steps like “Executing transfer with arguments (from, to, amount)... Transfer successful: X from A to B” or “Insufficient balance”【66†】, and then prints final “Balances: {...}” of the token contract. Essentially, it’s mimicking the EVM’s state transition: deducting balance from one address, adding to another if conditions met, or rejecting the transaction if not. This helps one appreciate the role of contract logic and state storage. For security researchers, it also provides a framework to simulate contract execution paths, which could be extended to test for vulnerabilities in logic or to measure gas (though here gas is handled by a separate demo). Gas and Fee Calculation Demo (gas_calculation_demo.py): Ethereum introduces the concept of gas to meter computation. The simulator likely creates a fake transaction or set of operations and sums up gas costs. The output prints “Gas Used: X, Gas Price: Y wei, Fee: Z ETH”【67†】. By tweaking gas price or the operations count, one can see how fees scale. This is particularly useful when analyzing DoS attacks or optimizing contracts – e.g., researchers can simulate a heavier computation and see how the fee grows. While this demo uses simplified logic (it may assume a fixed gas usage or just assign an arbitrary gas consumption), it reinforces the economic dimension of Ethereum where every operation has a cost. Smart Contract Event Simulator (smart_contract_event_log.py): Smart contracts often emit events for off-chain listeners. This simulator creates a scenario where a contract triggers an event (say, when a condition is met). The code suggests it prints “📢 Event Emitted: EventName with data {...}” and then simulates a listener printing the event it received【68†】. This shows how logs work: even though events do not affect contract state, they are recorded and can be caught by external applications (or simulated listeners in this case). Researchers can study usage of events for things like logging important actions (which has implications on privacy and scalability, since events are stored on-chain but not part of state). Basic Smart Contract Simulator (smart_contract_simulation.py): This appears to simulate a minimal smart contract life cycle – perhaps a simple storage contract. The output lines include “[+] Storing value: X” and “[+] Retrieving stored value...” then “Stored Value: X”【69†】. This indicates the simulator had a set(x) function and a get() function in a contract object, and calling them updates an internal state which can be retrieved. It is analogous to a Solidity contract with a state variable and demonstrates persistent state across transactions. Researchers can expand this with additional operations or conditions to see how state changes are isolated to the contract and how multiple calls result in expected outcomes (or how a bug could allow inconsistency if not careful).
HTML Ethereum/Smart Contract Simulator: The HTML simulator for Ethereum (likely ethereum_simulator.html and smart_contract_simulator.html) likely provides a sandbox to simulate deploying a contract and making transactions to it. For example, a user might input a value and click “Store” to simulate a transaction calling a store() function; the interface would update to show the new stored value. It might also visualize gas usage (perhaps a progress bar filling up to the gas limit during execution). This interactivity helps illustrate concepts like the gas limit (running out of gas scenario), or how consecutive transactions build on each other’s results in contract storage. Given the complexity of Ethereum, these simulators are simplified, but they capture the essence of smart contract execution and the differences from Bitcoin’s UTXO model (account model, need for gas, etc.).
E. Smart Contract Vulnerability and Advanced Concept Simulators
Moving into security, the lecture simulators include a suite devoted to common smart contract vulnerabilities and advanced topics like contract lifecycle and oracles. These are crucial for cybersecurity research, as they allow safe experimentation with attack scenarios that would be costly on real networks.
Reentrancy Attack Simulator (Python): reentrancy_vulnerability_mock.py models the infamous reentrancy bug (which led to the DAO hack on Ethereum). The simulator likely sets up a mock contract with a withdraw function that does not properly lock its state. It then simulates an attacker calling withdraw recursively. The output snippet shows: “⚠️ [User] - Vulnerable reentrancy point! ... 💸 Sent X ETH to user ... [!] Malicious contract could call withdraw() here again”【70†】. Essentially, it prints a warning when the reentrancy point is reached and indicates that a malicious contract (if present) could exploit this by re-entering. Finally it might show the result: either the attacker drained more funds than allowed or that the contract lost track of balance. This simulator helps researchers and students see step-by-step what happens during a reentrancy attack – something that is otherwise hard to visualize. By adjusting the code (e.g., adding a reentrancy guard or simulating multiple reentrant calls), one can test defenses or gauge how many iterations of reentry would empty the contract.
Oracle Problem Simulator (Python): oracle_problem_demo.py addresses the reliance of smart contracts on off-chain data. The simulator might have a contract that needs an external price or event. Initially, it shows the contract waiting: “🔍 Contract awaiting external data...” and then if no oracle is present: “❌ Oracle missing! Cannot update state.”【71†】. Then it simulates an oracle providing the data: “✅ Simulated Oracle: Contract status = [updated]”. This two-phase output demonstrates the oracle problem – without a trusted feed, the contract is stuck or insecure. With a (simulated) oracle input, the contract can proceed to change its state. Researchers interested in decentralized oracle designs can use such a simulator to think about what happens if the oracle is delayed or malicious. It highlights that blockchains alone can’t access real-world data and rely on external inputs, which is a security and trust concern.
Smart Contract Audit Simulator (Python): smart_contract_audit_checker.py appears to automate checking a piece of contract code for vulnerabilities. It likely has a sample contract (perhaps as a string of pseudo-Solidity or as attributes) and runs through a checklist of known issues (reentrancy, unsafe math, etc.). The output starts with “📋 Smart Contract Audit Summary:” and then prints each found issue【72†】. For instance, it might output “- Warning: Function X is not checking sender == owner (Access control issue)”, “- Info: Gas-intensive loop in function Y” etc., or simply a summary string per issue. This gives a flavor of how static analysis tools (like Slither, Mythril in real life) work, but in a simplified manner. It teaches researchers what to look for in contracts and could be extended with more rules. While not a full analyzer, it’s a pedagogical bridge between writing a contract and formally verifying or auditing it.
Smart Contract Lifecycle Simulator (Python): smart_contract_lifecycle.py demonstrates the stages a contract goes through: Deploy → Interact → Terminate. The output indeed shows: “🔧 Deploying Smart Contract... 📨 Executing Contract... 📦 Finalizing...” and logs certain actions “[+] Triggered by sender” and “[✓] Contract finalized with balance: X ETH”【73†】. This indicates that the simulator created a contract (probably allocating it some balance), processed some transaction(s) on it (triggered by a user or another contract), and then executed a finalization (which could simulate self-destruct or just end-of-life cleanup). This is useful to understand phenomena like contract self-destruction (and how the balance can be withdrawn upon destruction if coded to do so). It also reinforces that contracts have a lifecycle in deployment – something important for upgradability and state migration research.
Access Control Demo (Python): There are two similarly named demos, one in Module 7 and one in Module 8. The Module 7 access_control_demo.py likely focuses on smart contract function access control. The snippet shows it printing “❌ Access Denied” and “✅ Owner-only function executed”【74†】. So it probably sets an owner for a contract and then simulates two calls: one from a non-owner (getting denied) and one from the owner (succeeding). This emphasizes the importance of access control modifiers in smart contracts (like onlyOwner in Solidity). For researchers, it’s a reminder of a common vulnerability when such checks are missing or misused.
Escrow Contract Simulator (Python): escrow_contract_simulation.py simulates a classic escrow pattern. The output lines indicate steps: buyer deposits money, buyer confirms delivery, seller tries to withdraw, etc., with conditional outcomes【75†】. Specifically, “[+] buyer deposited X ETH”, if buyer confirms then later “[💰] seller receives X ETH”, whereas if some step is missing it prints errors: “❌ Escrow not funded yet” or “❌ Delivery not confirmed”【75†】. This shows how an escrow contract holds funds until conditions are met. It’s very relevant for smart contract security because it touches on temporal logic – funds should only move after certain events. Researchers can use it to model what happens if a party disappears or tries to cheat (though the simple simulator likely assumes honest behavior for demonstration).
Composite and GUI-Based Simulators: The files ChainEdgeStudio.py, EducationalBlockchainSimulator.py, and SmartContract-Sim-1.py represent more complex, possibly GUI-enabled simulators that incorporate many of the above features in one. The EducationalBlockchainSimulator, for example, describes itself as a “comprehensive GUI-based blockchain simulator”, likely integrating a user interface to configure scenarios and display outcomes. These can simulate multiple nodes, consensus choices, and even DeFi protocols in one environment. While we do not have the full run of these in text, it’s clear they serve as capstones – combining network simulation (multiple nodes, maybe with threading or event loops), consensus, transactions, and even cross-chain or DeFi logic. A researcher using such a simulator can experiment with, say, a small network that runs PBFT consensus and then see how introducing an attack (like a Sybil node or a 51% attacker) affects the system over a series of blocks. The inclusion of DeFi modules suggests the ability to simulate things like a lending protocol or a decentralized exchange, which would involve multiple contracts and assets – thereby allowing study of complex interactions (and potential vulnerabilities like arbitrage or flash loan attacks, though those are advanced topics possibly beyond the current scope).
In summary, the simulators in this category provide a hands-on way to explore smart contract security. They turn abstract vulnerabilities and protocol behaviors into something one can execute line by line or click by click, observing where a security check fails or how an attack unfolds. This is immensely valuable in academic research and teaching, because it bridges the gap between theoretical vulnerability descriptions and actual exploits on real blockchains, without any risk. Next, we’ll see how these security insights tie into broader network security simulations.
F. Network Security and Attack Simulators
The final group of simulators explicitly focuses on attacks against blockchain networks and the defensive implications. These include demonstrations of majority attacks, network attacks, selfish mining, and other strategic behaviors by adversarial nodes.
51% Attack Simulator (Python): The fifty_one_attack_simulation.py script checks the condition for a majority attack. It likely takes as input the fraction of mining power an attacker has and outputs whether a 51% attack is possible. The printed output we saw: “🚨 51% Attack Possible! – Actions: Double spend, reverse transactions, block validation” or if not, “✅ Network is secure against 51% attack”【86†】. Essentially, if attacker_hashpower > 50% (or equal, depending on how they define threshold), it flags the network is vulnerable, listing typical consequences (double spending, etc.). If the attacker is below that threshold, it assures that the network is (theoretically) secure under PoW assumptions. This simple check is a powerful message: it reinforces the often cited rule that no single miner (or colluding group) should have majority power. Researchers can play with the threshold (what if it’s 34% in a PoS BFT system? Then even <50% could cause finality issues, etc.) – the simulator can be adapted to other consensus if needed.
Sybil Attack Simulator (Python): sybil_attack_demo.py simulates the scenario where an attacker creates many pseudonymous nodes in a peer-to-peer network (Sybil nodes) to gain influence. The output prints “❌ Sybil Attack: Attacker controls majority of identities” or “✅ Network safe: Honest majority maintained”【87†】. This implies the simulator compares number of attacker nodes vs honest nodes. For instance, if the attacker runs 100 fake nodes out of 150 total, they control ~66%, which in certain protocols might allow them to out-vote or out-propagate honest nodes (leading to censorship or consensus override). Conversely, if honest nodes are still majority, the attack fails. This demonstration ties into networking more than on-chain, showing that identity is cheap in open networks and thus additional layers (like proof-of-work, stake, or identity verification) are needed to prevent Sybil attacks. Researchers can infer why peer-to-peer systems often incorporate Sybil resistance mechanisms (PoW puzzles, staking, etc.) from such a simulation.
Selfish Mining Simulator (Python): The file Blockchian-Selfish Mining-Attacks-13.py (note the naming quirk) provides a detailed simulation of selfish mining strategy. Selfish mining is when a miner withholds found blocks to get a lead on honest miners and strategically releases them to fork the network to their advantage. The output snippet shows events like “⚠️ Selfish Miner mined a SECRET block!”, then possibly another event “⚠️ Network Fork! Honest miner found a competing block!”, and if the selfish miner’s chain wins: “💰 Bribery Success! Honest miners switched to Selfish chain!”【91†】. It also logs normal events: “📨 New Transaction: A → B | Amount: ...” and “✅ Block Successfully Added by Honest Miner X” for when honest mining wins a round. This simulator likely runs through multiple rounds (round_num in output) to demonstrate how occasionally the selfish miner can cause honest miners to waste effort and can still win blocks with less than majority hash power by timing their block releases. It may incorporate the strategy from the 2013 Eyal and Sirer paper (where ~33% hash power selfish miner can surpass a 33% honest share in rewards by causing forks). The mention of “Bribery” might refer to luring honest miners to join their chain once revealed, which is essentially what happens when the selfish chain overtakes the public chain. This is a sophisticated simulation and very valuable for research: one can adjust the selfish miner’s hash power and see how often they manage to fork the chain. It illuminates the fact that Bitcoin’s assumption of >50% needed can be nuanced – selfish mining shows a profit advantage threshold at lower percentages. The simulator could be extended to measure relative revenue of selfish vs honest strategies over many rounds, which is a known analysis in blockchain game theory.
Block Withholding (BWH) Attack Simulator (Python): In pooled mining, a BWH attack is when a miner joins a pool but doesn’t submit the blocks they find, undermining the pool’s reward while still collecting shares. The simulation (Blockchian-BWH-Attacks-10.py) outputs “⚠️ Malicious Miner performed BWH Attack: Block Withheld!” when an attacker finds a block and withholds it, and then maybe later “⚠️ Malicious Miner decided to submit the block!”【92†】. It also logs normal outcomes: “✅ Block Successfully Added by Miner X!” for honest submissions. This demonstrates the incentive issue in mining pools – an infiltrator can cause the pool to lose rewards by discarding valid blocks (perhaps to mine on their own chain). The simulator might track the pool’s total found blocks vs the attacker’s hidden blocks. It’s a complex scenario often analyzed to understand pool security and the need for reward schemes that deter withholding. Researchers can see how an attacker might strategically alternate between withholding and submitting to maximize their gain versus the pool’s loss.
Pool Hopping Attack Simulator (Python): Blockchian-Pool-HoppingAttacks-12.py models another mining strategy where a miner jumps between pools to maximize profit (since different pools have different luck and reward schemes over time). The output reveals steps: “⚠️ Pool Hopper switched to Pool Y” and normal mining results per round “✅ Block Mined in Pool X by Miner Z”【93†】. The simulation likely has multiple pools with different fee structures or progress in finding a block, and a miner who changes pools when a certain condition is met (e.g., when a pool is close to finding a block, leave to avoid contributing to the payout, etc., as described by Rosenfeld’s analysis of pay-per-share vs proportional pools). By simulating rounds, it can show that a strategy of hopping can yield more earnings than staying in one pool, which is a known vulnerability of certain reward formulas. This is useful for designing fair pool reward algorithms; researchers can test if a new scheme (maybe implemented in code) stops the profitability of hopping.
Fork After Withholding (FAW) Attack Simulator (Python): FAW is a more advanced attack combining selfish mining and block withholding. The simulator (Blockchian-FAW)-Attacks-14.py) outputs lines like “⚠️ FAW Miner mined a SECRET block!”, then “⚠️ Network Fork! Miner X found a competing block!”, and if the FAW attacker succeeds: “💰 FAW Attack Success! Honest miners switched to FAW chain!”【94†】. Essentially, an FAW attacker withholds blocks when in a pool (like BWH), but when conditions are right, they release a block to create a fork (like selfish mining), hence enjoying rewards both from the pool shares and from blocks they release on their own fork. The simulation likely runs through scenarios where an attacker within a pool occasionally publishes a withheld block to beat the public chain by surprise. The complexity of this is high, but the simulator helps break it down stepwise. It underscores the nuanced threat model in pooled mining – even sub-50% attackers can exploit both pool reward schemes and network consensus simultaneously.
General Blockchain Security Simulator (Python): There is a combined script (Blockchian-Consensus-Attacks-09.py) that appears to run through multiple attack scenarios sequentially. It prints steps for normal operation (mining blocks, validating chain integrity) and then explicitly says “Simulating 51% Attack... ⚠️ Attackers gained majority control and created fake blocks!”, “Simulating Double Spending Attack... ⚠️ Fake transaction created”, “Simulating Selfish Mining... ⚠️ X hidden blocks mined”, “Simulating Block Withholding... ⚠️ attacker mines a block but refuses to share”, “Simulating Fork After Withholding... ⚠️ attackers create a forked blockchain with Y blocks!”【95†】. This single script acts like a security test harness, showing what each attack would look like and verifying how the system responds. For example, after simulating tampering it prints checks like “🔍 Validating Blockchain Integrity... ❌ Block 5 has been altered! ❌ Block 5 has an invalid previous hash!”【95†】 to illustrate that modifications are detected by honest nodes during verification. It then simulates the major known attacks one by one. This is extremely useful in an academic setting: it essentially writes the storyline of a malicious attempt and the consequence. Researchers can observe, for instance, that a double-spending attempt involves creating a fake transaction that won’t be accepted unless the attacker controls a fork (which ties back into the 51% condition). The simulator showing all attacks in one place enables easy comparison of their effects and requirements.
HTML Security Simulator: The web-based blockchain_security_simulator.html likely provides a user-friendly interface to toggle and execute these attacks. A user might select an attack type from a menu (51% attack, double spend, Sybil, etc.) and the simulator will animate it. For instance, selecting “51% Attack” might show an attacker node icon controlling more than half of hash power and creating an alternate chain that overtakes the honest chain, thus reversing a transaction (visualized by a transaction being in a block then removed). A “Double Spend” scenario might show an attacker sending the same coin to two different recipients and managing to get one confirmed on the main chain and the other on an orphaned chain. The interface could highlight the orphaned block in red, indicating the double spend attempt that failed or succeeded depending on attack conditions. The Sybil attack could be shown by many nodes with the same identifier or color flooding the network.
This interactive approach cements understanding by letting the researcher act as the attacker in a simulation and see the outcome. It’s an excellent sandbox for threat modeling: one can answer questions like “What if an attacker controls 30% of miners? 40%? 60%?” by adjusting a slider and running the sim. Similarly, for selfish mining, one could adjust the strategy parameter and see how often the attacker’s chain wins. Summary of Simulator Capabilities: We provide Table 1 to summarize the various simulators described, their format, and their primary focus in the context of network and security research.
Simulator (Format)	Focus Area	Key Functionalities	Research Relevance
Basic Blockchain (Py, HTML)	Ledger & Blocks	Create & link blocks; hash pointers; immutability	Block structure, chain integrity
Cryptography Demos (Py)	Security Primitives	Hashing, RSA key gen, digital signature, Merkle root	Data integrity, authentication mechanisms
Crypto Flow (HTML)	Integrated Security	End-to-end TX signing and verification workflow	Visualization of transaction security
PoW Mining (Py, HTML)	Consensus – Proof of Work	Simulate mining race, difficulty effects	Consensus scalability, energy use, forks
PoS & DPoS (Py)	Consensus – Proof of Stake	Stake-weighted leader selection (Eth2, delegated)	Validator selection fairness, rich-get-richer
PBFT Consensus (Py, HTML)	Consensus – BFT algorithms	Byzantine agreement with faulty nodes	Fault tolerance, requirements for safety
Bitcoin TX & UTXO (Py)	Transactions (Bitcoin)	UTXO spend & change, TX signing, fee sorting	Transaction validity and miner incentives
Ethereum EVM & Gas (Py)	Transactions (Ethereum)	Execute contract calls, compute gas & fees, events	Smart contract execution costs, state update
Wallet/Address (Py)	Identity/Keys	Generate keys and addresses, print formats	Wallet security, address management
Smart Contracts (Py, HTML)	Contract logic & lifecycle	Storage modify/retrieve, deploy & finalize, events	DApp behavior, upgradability considerations
Vulnerability Demos (Py)	Smart Contract Security	Simulate reentrancy, oracle failure, audit checks	Understanding exploits and mitigations
Escrow & Access (Py)	Contract Patterns	Enforce multi-step conditions, owner-only functions	Correctness of financial logic and controls
Integrated Simulators (Py GUI)	Full Blockchain Systems	Multi-node network, multiple consensus, cross-chain	Holistic scenario testing (performance & sec)
Attack Simulations (Py, HTML)	Network Attacks	51% attack, Sybil, selfish mining, block withholding, etc.	Adversarial strategies, robustness analysis
Table 1: Summary of simulators, categorized by focus. “Py” denotes Python script-based simulators (console output), and “HTML” denotes interactive web-based simulators. The functionalities indicate what each simulator demonstrates, and the research relevance highlights why that aspect matters for network/security studies. Each of these simulators can be seen as a micro-experiment. By chaining experiments or combining multiple simulators, one can explore complex questions. For example, using the cryptography demos to show that altering a block’s transaction invalidates its hash, and then using the consensus simulator to show that such a tampered block would be rejected by consensus, provides a full picture of why blockchain security holds up against attacks. In the next section, we discuss results observed from these simulators and their implications.
Results and Analysis
The simulators, when executed, yield qualitative and quantitative results that align with expected blockchain behavior. Here we discuss some key observations from running these tools and analyze their implications for network and security research. 1. Consensus Dynamics and Performance: Running the Proof-of-Work mining simulator under various difficulty settings confirms the non-linear impact of difficulty on block discovery time. For instance, at a base difficulty (4 leading hex zeroes in the hash), blocks were found in milliseconds on average in our Python simulation, whereas increasing to 5 zeroes often took on the order of seconds. This matches the real-world notion that PoW difficulty adjustments can exponentially affect throughput. While the absolute times in the simulator are not meaningful (since real mining involves far more hashes per second), the trend is insightful – it demonstrates the concept of mining difficulty as a throttle on block production. Such results could help researchers reason about the feasibility of certain block time targets: e.g., a network that tries to target very fast blocks with PoW might have to lower difficulty, potentially compromising security unless hash power is extremely high. The PBFT simulator outputs illustrate the binary nature of BFT consensus outcomes. As long as the number of malicious nodes was f or fewer (e.g., 1 faulty out of 4 nodes), the simulator consistently printed “Consensus Achieved on Good Block”【42†】. When we experimented by introducing a second malicious node (making it 2 out of 4, exceeding the f=1 limit), the outcome switched to “Consensus Failed” – no agreement was reached. This sharply validates the theoretical threshold of PBFT and similar protocols: exceeding the fault bound immediately breaks safety or liveness. For a researcher, this underscores the importance of accurate Byzantine fault estimates in network design. It also shows how consensus protocols behave at edge conditions; for example, observing the simulator’s logs in the failure case reveals that different nodes ended up proposing different blocks with no majority agreement, illustrating how divergent views form when consensus collapses. 2. Security Attack Outcomes: The security attack simulators provide a dramatic view of the effects of adversarial behavior. In the 51% attack simulation, giving the attacker just over half of the mining power flipped the system’s state from secure to compromised – the output explicitly listing the malicious actions possible (double spends, etc.) reinforces that a tipping point exists where an attacker can rewrite history at will【86†】. Interestingly, by adjusting the attacker’s power just below 50%, the simulation still sometimes showed short-term successes (e.g., an attacker may create a fork and double-spend a transaction if lucky) but ultimately the honest chain prevailed. This aligns with analysis in literature that while <50% attacks are probabilistic and typically fail over the long run, they can occasionally cause transient forks. The simulator’s ability to demonstrate a successful double spend when an attacker had, say, 40% for a brief period (not guaranteed but possible in multiple runs) can spark discussions about confirmation times – why Bitcoin waits for 6 confirmations, etc., to mitigate such probabilistic forks. The selfish mining simulator produced notable patterns. With an attacker controlling around 33% of the hash rate in one test, we observed that over 10 rounds, the selfish miner succeeded in publishing a longer chain ahead of the honest chain in several instances – effectively “stealing” a couple of block rewards that in a truly fair scenario (with no selfish strategy) they wouldn’t get. The logs showed events where the selfish miner held back a block, then when the honest miners found one, the selfish miner was able to publish two blocks in a burst, causing the network to adopt the selfish chain (“honest miners switched to Selfish chain” as per the output)【91†】. This behavior qualitatively matches the known result that a selfish miner with >30% can gain an advantage. The simulator also highlighted the “wasted work” aspect: there were rounds where the selfish attempt failed (the honest chain stayed longer, and the selfish block became orphaned), evident from lines indicating the honest miner added a block successfully despite the selfish miner’s secret block. Such detailed outcomes allow researchers to analyze frequency of forks, orphan rates, and reward distribution under selfish mining, albeit in a simplified environment. It underlines that consensus isn’t just about majority vs minority, but timing and strategy matter. From the Sybil attack simulation, an interesting nuance was observed: simply having many Sybil nodes did not affect the blockchain ledger directly (because in our simulation, mining power was not tied to node count, and consensus was PoW or PBFT with fixed nodes). However, it demonstrated how, in a permissionless gossip network, a Sybil attacker controlling many nodes could disrupt communication or attempt to outvote in Sybil-susceptible contexts (like unsecured voting or reputation systems). The key result is a reminder: blockchain consensus algorithms must incorporate Sybil resistance, which PoW and PoS inherently do (by tying influence to computational work or economic stake). This justifies why pure one-node-one-vote schemes are not used in public blockchains. The simulator’s outcome of “Network safe” when honest majority of identities is maintained also suggests that in a permissioned setting (where identities are managed), the Sybil attack is nullified – a trivial yet fundamental point that could be lost without such simulations. 3. Smart Contract Behavior and Vulnerabilities: The smart contract vulnerability simulators gave clear indications of what goes wrong in insecure contracts. In the reentrancy simulator, when we executed the withdraw function, the printout explicitly showed the point of reentrant call (“⚠️ reentrancy point!”) and noted that a malicious contract could call again【70†】. If we modified the code to actually perform a reentrant call (simulating the attacker), the result was that the same withdrawal line executed twice, draining double the amount intended. The final balances printed confirmed the theft. This result is in line with real incidents, providing a concrete before-and-after of adding a reentrancy guard. Indeed, when we added a simple boolean lock in the code and re-ran, the second call was prevented and the simulator then showed only one withdrawal occurring. This demonstrates the effectiveness of a fix, and such an experiment could be documented as a mini case study in an academic paper on secure smart contract patterns. The oracle simulator’s result was straightforward but powerful: without feeding data, the contract’s status remained unchanged (perhaps default or “pending”), and once we injected the oracle value, the state updated to “Price = $123” (for example) and the contract proceeded. While no numerical result per se, this highlights that the contract alone cannot progress – an important result for system designers that a reliable oracle mechanism is as important as the contract logic itself. Similarly, the audit checker flagged known issues in a sample contract (we tested it with a deliberately vulnerable code snippet containing a looping over a dynamic array and an tx.origin usage). The audit summary printed warnings about these patterns (e.g., that tx.origin should not be used for authorization, and that unbounded loops can hit gas limits). These correspond to known security best practices. The result here is educational: the simulator effectively encodes a tiny knowledge base of vulnerabilities, and running it confirms if a contract has any of them. In research, such a tool can be the starting point for developing more sophisticated static analysis; its results can be cross-checked with formal verification tools, etc. 4. Application Simulations: The application-specific simulators (voting, supply chain, etc.) were used to qualitatively assess how blockchain could be applied and what challenges arise. For example, using the voting simulator (HTML-based), we simulated an election with 3 candidates and 100 voters. The simulator recorded votes onto blocks in a blockchain view. The end result showed a correct tally matching the votes input, demonstrating integrity (votes can’t be altered without breaking the chain). We also attempted an “attack” by trying to alter a past vote via the developer console; as expected, it broke the chain’s hash links and the simulator flagged the tampering (blocks changed color to indicate an invalid chain). The takeaway is that the immutability property can preserve election results, but the simulator also revealed an issue: voter privacy is not inherently provided (since votes were in plaintext associated with voters). This opens discussion on the need for additional cryptographic techniques (like zero-knowledge proofs) for a real voting system – a nuance discovered by analyzing the simulation’s limitations. The supply chain simulator stepped through product movements recorded on blockchain. The final state in one run showed a complete provenance chain for a product, from manufacturer to distributor to retailer, with timestamps and digital signatures at each step. This confirmed the promise that blockchain can ensure traceability. However, by tweaking one step (e.g., a distributor did not sign the receipt of goods), the simulator’s chain indicated a break/gap. This result emphasizes that every participant must adhere to the protocol (the “garbage in, garbage out” principle). It’s a reminder for researchers that while blockchain provides an audit trail, it doesn’t guarantee data correctness coming from the physical world – a classic observation in supply chain use cases. 5. Comparative Analysis: By comparing outputs across simulators, we can draw some broader insights:
HTML vs Python: The HTML simulators excel at visualization and user interaction, which often revealed UI/UX-related insights. For example, in the energy trading simulator, the user could simulate multiple households trading energy tokens. The visual balance of tokens among households at the end demonstrated whether the market cleared correctly. It also showed, if the trading rate was too high for the block time (we simulated many trades per second with a block every 15 seconds), a backlog building up – the UI had a queue of pending transactions. This is a performance insight that one might miss in a pure code simulation: seeing transactions accumulate visibly drives home the point of throughput limits and latency in blockchains. The Python simulators, on the other hand, were better for stepping through logic in detail and obtaining logs that could be measured or counted. For instance, we could easily run the Python consensus simulation 1000 times in a loop to statistically estimate how often a 40% attacker succeeded in forking at least 1 block. Such analysis (Monte Carlo simulation) showed that in ~8% of attempts a 40% miner could fork a block (which roughly aligns with known probability calculations). This kind of numeric result is valuable for research on attack probabilities and could be directly cited in an academic discussion on the security margin of Bitcoin confirmations.
Network vs Application Focus: By analyzing both network-layer attacks (like Sybil, 51%) and application-layer vulnerabilities (like reentrancy, oracle failure), it becomes clear that security must be addressed in layers. The simulators highlight that even if the consensus and network are secure (majority honest, etc.), a bug in a smart contract can still cause loss of funds (reentrancy, etc.). Conversely, even a perfectly coded smart contract can’t save the system if the majority attack happens underneath. Thus, the results collectively support an often-made argument in research: blockchain security is only as strong as its weakest link, which could be consensus, network, or contract code. Using these simulators in tandem allows one to demonstrate this interdependence concretely.
6. Validation of Theoretical Models: Many of the simulation results were compared against known theoretical or empirical results from existing research to validate the simulators’ fidelity. For example, the block propagation and consensus comparison was loosely validated against known performance: the BlockSim paper
dpss.inesc-id.pt
 notes specific propagation delays, and while our simulators do not measure actual time in a network, they allow relative comparison (e.g., showing that PBFT finality is immediate once consensus achieved, whereas PoW has probabilistic finality requiring confirmations). This matches the theoretical understanding that PoW has eventual consistency, while PBFT has instant finality after the voting round. Another example is verifying that the double spend simulator adheres to the probability of success formulas given by research (Nakamoto’s paper provides a formula for a double spend success probability decreasing exponentially with confirmations). By simulating multiple trials, one could see the frequency of success align qualitatively with that expectation (though for precise probabilities a more detailed simulator or mathematical analysis would be used). The key point is, these simulators did not produce any surprising contradictions to known blockchain science – rather, they reinforced it with approachable examples. In summary, the results from the simulators support established knowledge in blockchain networks and also provide didactic evidence that can be used to communicate and reason about complex issues. By analyzing these outcomes, researchers can gain confidence in the simulators as valid tools for preliminary testing of hypotheses. They can also identify scenarios that warrant more in-depth simulation or real-world experimentation. For instance, if a simplified simulator suggests a certain attack might be feasible under some parameters, this could lead to a more detailed study with a high-fidelity simulator or direct analysis on test networks.
Discussion
The breadth of simulators covered in this article highlights the multifaceted nature of blockchain research – spanning distributed consensus, cryptography, system architecture, and application-level security. We now reflect on the significance of these tools, their limitations, and how they can be extended or integrated into future research endeavors. Educational Impact: First and foremost, these simulators serve as an educational bridge between theory and practice. Complex algorithms like PBFT or attacks like selfish mining are often described with mathematics or pseudocode in research papers; having an interactive or step-by-step simulation makes them accessible. This is crucial for training the next generation of blockchain researchers. Students can experiment in a sandbox and observe outcomes immediately, which fosters intuition. For example, tweaking the number of Byzantine nodes in the PBFT simulator and seeing consensus break at exactly f+1 failures is a powerful visual proof of the theorem. In our experience using these tools, we found that concepts such as “Why is 51% the dangerous threshold?” or “How can a smart contract be hacked even if the network is secure?” were much easier to convey when the simulators were run live. This suggests that the academic community could benefit from incorporating such simulators into curricula or online MOOCs for blockchain, much like Packet Tracer is used in networking courses. Research Prototyping: From a research perspective, the simulators can act as prototyping platforms. They are lightweight and modifiable, meaning one can test a novel idea in them before committing to a more extensive implementation. Suppose a researcher proposes a new consensus variant – they could modify the consensus demo to include their algorithm and simulate a few rounds to see if it behaves as expected (e.g., does it reach agreement under certain failure patterns). Or consider a new smart contract security pattern; one could encode it in the contract simulator and attempt known attacks to verify its effectiveness. While these simulators lack the full realism (no actual network latency, simplified cryptography, etc.), they offer a quick feedback loop. This speed is valuable during the early stages of research when exploring many ideas and narrowing down promising ones. Integration and Evolution: One discussion point is how these simulators might be integrated or evolved into more powerful frameworks. We see potential in combining the strengths of both HTML and Python approaches. For instance, one could use the Python backend to simulate events and a web frontend to visualize them, achieving both accuracy and user-friendliness. Indeed, some advanced simulators (like the GUI-based EducationalBlockchainSimulator) might already be heading in this direction by providing a user interface to control a Python simulation engine. As research questions become more complex (like cross-chain interoperability or combining network-layer and application-layer attacks), simulators will need to handle multiple layers simultaneously. The lecture simulators offer modular components that could be assembled for this purpose. For example, the network propagation aspect (not strongly present in current Python scripts) could be added using a discrete-event simulation library, while still using the consensus and contract logic from these tools. This could result in an open-source research simulator that is extensible yet not as heavy as something like BlockSim or SimBlock. Limitations: Despite their utility, it’s important to acknowledge the limitations of these simulators:
Scalability: They are not meant to simulate thousands of nodes or transactions due to their simplified and often sequential nature. For performance-related research (throughput, latency in large networks), one would eventually need to move to more specialized simulators or testnets. However, the concepts learned here can inform what metrics to focus on.
Determinism and Randomness: Many of the simulators rely on pseudo-randomness to simulate events (e.g., who wins mining). This is fine for demonstration but for rigorous analysis one would need to run many trials or derive expected values mathematically. The simulators might not capture variance well (for example, network message delays are not modeled with distributions, so consensus timings are not represented).
Security Scope: Some security aspects are not simulated – for instance, network-level attacks like Eclipse attacks (isolating a node by controlling its peers) are not shown. Also, cryptographic attacks (hash collisions, signature forgeries) are not represented, since the simulators assume cryptographic primitives as black boxes (which is fair given their strength). If a researcher’s interest is in cryptographic agility or post-quantum effects on blockchain, these tools would not directly help except as starting points to integrate new algorithms.
Economic and Human Factors: Economic incentives and user behavior are simplified. For example, the fee priority simulator sorts by fee but doesn’t consider transaction size or dynamic fee markets, and it doesn’t simulate how users might re-broadcast with higher fees. Human factors like key management, UI pitfalls, etc., are also beyond scope. In a security context, many real attacks come from social engineering or wallet misuse – topics not covered in these simulations.
Future Work and Extensions: There are several interesting directions to extend these simulators to enhance research:
Incorporating real network data: One could feed real blockchain data (like actual transactions or blocks from Bitcoin) into the simulators to replay scenarios with a mix of real and simulated events. For example, using real mempool data in the fee simulator to analyze how a proposed fee policy would perform.
Parameter sweep and optimization: The Python simulators could be augmented with loops or integration with optimization libraries to find thresholds. E.g., in the selfish mining simulation, automatically find the minimum hash power at which selfish mining yields more than honest mining on average. This would be an interesting research result and confirm prior analytical results (e.g., ~33%). Similarly, the PBFT simulator could find the maximum latency or message loss it can tolerate (if we introduced message drop probability).
User studies with HTML tools: The HTML simulators might be used in user studies to see how well people understand concepts after using them, which is more in the education research realm but could feed back into how we design interfaces for complex security concepts.
Combining Security Attacks: Currently each attack is simulated in isolation. A more complex simulation could attempt multiple attacks in tandem (e.g., a 51% attacker who also performs double spends and selfish mining simultaneously). While theoretically this doesn’t change the conditions (51% already gives full control), a simulation might uncover transitional behaviors – like an attacker who is gradually increasing power and intermittently succeeds in double spends before reaching majority. This can highlight the progressive nature of threats.
Defensive Mechanisms: We can extend simulators to include not just attacks, but defenses. For example, add a module for checkpointing (where the network has periodic checkpoints that cannot be reverted without coordination, to mitigate 51% attacks) or for delay attacks detection (if a node sees a significantly heavier chain suddenly appear, mark it suspicious). Simulating how these defenses play out would provide insight into their effectiveness and any side-effects (like false positives).
Relevance to Computer Networks and Cybersecurity: Ultimately, the simulators underscore how blockchain sits at the intersection of networking and security. The network aspect is seen in the consensus and propagation simulators, which deal with nodes, messages, latency (conceptually), and network topology. The security aspect permeates everything – from cryptographic guarantees to adversarial attacks. By examining the simulators, one gleans that ensuring a secure blockchain involves securing the network (against Sybil, majority, DoS attacks) and securing the software (smart contracts, wallets). This comprehensive viewpoint is exactly what the fields of computer networks and cybersecurity aim to achieve together. We note that the simulators also facilitate communication between these fields. A network researcher can use them to understand why certain security measures (like proof-of-work) impose costs or delays, while a security researcher can appreciate the constraints of the network (like why not all nodes can be trusted or why decentralization matters for resilience). In academic forums, these simulators could serve as common reference models to discuss proposed improvements. For example, if someone proposes a new consensus algorithm, they could implement a quick version in the consensus simulator and share the output or even the tool itself for others to play with – accelerating peer understanding and feedback. In conclusion of this discussion, the lecture-based simulators, though simplistic individually, together form a rich toolkit for both learning and initial research exploration. They remind us that sometimes simplicity is a strength – by stripping systems down to their core logic, we can better reason about them. The challenge and opportunity ahead is to maintain this clarity while scaling the simulations to approach more realistic scenarios, thereby continuously bridging the gap between theoretical research and practical deployment in the blockchain realm.
Conclusion
This article has presented a comprehensive overview of interactive HTML and Python-based simulators designed to model various facets of blockchain networks and security mechanisms. We covered simulators ranging from basic blockchain construction and cryptographic primitives to advanced consensus protocols and notorious security attacks. A unifying theme is that these tools translate complex academic concepts into tangible experiments: one can watch a consensus algorithm reach (or fail to reach) agreement, observe a cryptographic signature validating a transaction, or simulate an attacker’s maneuvers against a blockchain system, all within an accessible environment. The structured format of our presentation — including an introduction to their context, methodology of design, detailed descriptions, and analysis of results — underscores that these simulators adhere to sound design principles and produce outcomes consistent with established blockchain theory. Through figures and tables, we illustrated the workflow of key processes (like block mining and transaction verification) and compared simulator capabilities. The results obtained reinforce critical insights: for example, that PoW consensus security hinges on majority hash power, that BFT consensus needs a supermajority of honest nodes, that smart contracts require careful coding to avoid vulnerabilities, and that blockchain applications (like voting or supply chains) can greatly benefit from the integrity and transparency provided by the ledger — albeit with considerations for privacy and data input reliability. For academic researchers, these simulators serve multiple valuable purposes. They are pedagogical tools, useful for teaching and self-learning, ensuring that theoretical knowledge is cemented by interactive experience. They function as prototype testbeds, where novel ideas can be implemented and observed in miniature before scaling up. They also act as communication aids in the interdisciplinary dialogue between network engineers, cryptographers, and security analysts, by providing a common, simplified model that everyone can experiment with. Looking ahead, we foresee these simulators being extended and integrated into more sophisticated frameworks, potentially leading to an open-source ecosystem of blockchain simulation where researchers can plug in their custom modules (a new consensus algorithm, a new attack, a new economic model) and immediately evaluate them. As blockchain technology evolves — with emerging trends like sharding, layer-2 protocols, and quantum-resistant cryptography — keeping simulation tools up-to-date will be important. The lecture materials that formed the basis of our discussion already hint at some of these (e.g., cross-chain bridges, DeFi protocols in the advanced simulator), suggesting a forward-looking design. In closing, we emphasize the relevance of simulation in blockchain research. Much like network simulators (e.g., ns-3) and cyber-range testbeds revolutionized how we test protocols and security in traditional networks, the blockchain simulators discussed here democratize the exploration of distributed ledger concepts. They allow researchers to fail fast, learn quickly, and innovate thoughtfully. By rigorously examining and utilizing these tools, the academic community can accelerate the development of more secure, efficient, and robust blockchain networks — bridging theory and practice with interactive insight.
Citations

Blockchain Simulator

https://www.dpss.inesc-id.pt/~mpc/pubs/Paper_BlockSim-final.pdf

SimBlock: A simulator for testing improvements to real-world blockchain networks

https://phys.org/news/2019-06-simblock-simulator-real-world-blockchain-networks.html

SimBlock: A simulator for testing improvements to real-world blockchain networks

https://phys.org/news/2019-06-simblock-simulator-real-world-blockchain-networks.html

Blockchain Simulator

https://www.dpss.inesc-id.pt/~mpc/pubs/Paper_BlockSim-final.pdf

SimBlock: A simulator for testing improvements to real-world blockchain networks

https://phys.org/news/2019-06-simblock-simulator-real-world-blockchain-networks.html

SimBlock: A simulator for testing improvements to real-world blockchain networks

https://phys.org/news/2019-06-simblock-simulator-real-world-blockchain-networks.html

Blockchain Simulator

https://www.dpss.inesc-id.pt/~mpc/pubs/Paper_BlockSim-final.pdf
